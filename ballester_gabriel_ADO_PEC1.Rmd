---
title: "ballester_gabriel_ADO_PEC1"
author: "Gabriel Ballester Lozano"
date: "4/21/2020"
output: pdf_document
---

```{r setup, include=FALSE, warning=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(knitr)
knitr::opts_chunk$set(echo = TRUE, message = FALSE, warning = FALSE, 
                      comment = NA, prompt = TRUE, tidy = FALSE, 
                      fig.width = 5, fig.height = 5, fig_caption = TRUE,
                      cache=FALSE)
library(ggplot2)
library(ggrepel)
library(oligo)
library(Biobase)
library(GEOquery)
library(arrayQualityMetrics)
library(ggplot2)
library(ggrepel)
library(pvca)
library(genefilter)
library(mogene21sttranscriptcluster.db)
library(limma)
library(gplots)
library(ReactomePA)
```

## Estudio escogido

El estudio que he escogido para realizar la presente PEC es el estudio [https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE133975](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE133975), pubicado el 17 de abril de 2020 y titulado "Reprogrammed alveolar macrophages after pneumonia recovery". El organismo de estudio es Mus musculus y el diseño del estudio es comparativo 

Obtenemos los datos del estudio, aunque dada la extensión de la lista de phenodata, preferimos realizar nuestra propio archivo de targets para simplificarlo:
```{r ReadCELfiles, message=FALSE, results='hide', warning=FALSE}
#elist <- getGEO("GSE133975")
celFiles <- list.celfiles("./data", full.names = TRUE)
my.targets <-read.AnnotatedDataFrame(file.path("./data","targets.csv"), 
                                     header = TRUE, row.names = 1, 
                                     sep=";") 
rawData <- read.celfiles(celFiles, phenoData = my.targets)
my.targets@data$ShortName->rownames(pData(rawData))
colnames(rawData) <-rownames(pData(rawData)) 

```
En el estudio usaron microarrays para detallar la expresión génica de macrófagos alveolares de ratones infectados con la bacteria que causa la neumonía denominada pneumococcus -aunque en la id de las muestra contendrá el valor de SP3-, que se dividen en dos grupos (cada uno con su control); ratones "naive" y ratones ya infectados y recuperados pasado un més. A ambos ratones se les tomó una muestra de pulmón para el análisis de macrófagos, que son las células objetivo de este estudio.

La plataforma de Affymetrix utilizada para este estudio es [MoGene-2_0-st] Affymetrix Mouse Gene 2.0 ST Array [mogene20st_Mm_ENTREZG_17.1.0](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GPL17791) basada en oligonucleotidos in situ. Por ello, cabe esperar que el paquete de anotaciones de bases de datos de bioconductor "mogene21sttranscriptcluster.db" sea el adecuado para las anotaciones de los genes correspondientes.

El presente archivo y sus resultados se hallan disponibles en el repositorio de Github [https://github.com/GABRIELBALLESTER/Ballester_Gabriel_ADO_PEC1.git](https://github.com/GABRIELBALLESTER/Ballester_Gabriel_ADO_PEC1.git)

## Control de calidad

Al crear el directorio "arrayQualityMetrics_report_for_rawData" observamos el archivo index.html y vemos que tan solo hay una marca en algunos arrays por lo que se puede decidir seguir adelante con todos;

```{r}
#arrayQualityMetrics(rawData)
```

```{r QCRawDataRes, fig.cap="Tabla resumen de los datos del estudio", echo=FALSE}
knitr::include_graphics("Figuras/Overvieiw.png")
```

Sin embargo, para un control de calidad de los datos brutos más exhaustivo, procederemos con el siguiente análisis de componentes principales o PCA;
```{r}
plotPCA3 <- function (datos, labels, factor, title, scale,colores, size = 1.5, glineas = 0.25) {
  data <- prcomp(t(datos),scale=scale)
  # plot adjustments
  dataDf <- data.frame(data$x)
  Group <- factor
  loads <- round(data$sdev^2/sum(data$sdev^2)*100,1)
  # main plot
  p1 <- ggplot(dataDf,aes(x=PC1, y=PC2)) +
    theme_classic() +
    geom_hline(yintercept = 0, color = "gray70") +
    geom_vline(xintercept = 0, color = "gray70") +
    geom_point(aes(color = Group), alpha = 0.55, size = 3) +
    coord_cartesian(xlim = c(min(data$x[,1])-5,max(data$x[,1])+5)) +
    scale_fill_discrete(name = "Group")
  # avoiding labels superposition
  p1 + geom_text_repel(aes(y = PC2 + 0.25, label = labels),segment.size = 0.25, size = size) + 
    labs(x = c(paste("PC1",loads[1],"%")),y=c(paste("PC2",loads[2],"%"))) +  
    ggtitle(paste("Principal Component Analysis for: ",title,sep=" "))+ 
    theme(plot.title = element_text(hjust = 0.5)) +
    scale_color_manual(values=colores)
  }
```

```{r PCARaw, message=FALSE, fig.cap="Análisis de Componentes Principales de rawData"}
plotPCA3(exprs(rawData), labels = rawData@phenoData@data[["ShortName"]], factor = rawData@phenoData@data[["Group"]], 
         title="Raw data", scale = FALSE, size = 3, 
         colores = c("red", "blue", "green", "yellow"))
```

Tras ver estos resultados he comprobado que los etiquedados están correctamente, puesto que hay dos Arrays que se separan bastante del resto (E.C.3 y E.SP3.4), ambos pertenecientes al tipo "experienced" pero no del mismo grupo experimental. Estos resultados tambien se encuentran en la carpeta "arrayQualityMetrics_report_for_rawData". Quizá deberían eliminarse de los posteriores análisis puesto que estos dos Arrays se encuentran a ambos lados del eje que explica el 49.6% de la variabilidad, no obstante continúo teniéndolos en cuenta y efectuamos el análisis de boxplot;
```{r BoxplotRaw, message=FALSE, fig.cap="Boxplot de los Arrays con datos brutos"}
boxplot(rawData, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 4), rep("blue", 4), rep("green", 4), rep("yellow", 4)),
         main="Distribución de los valores de intensidad de los Arrays")
```

Una vez más, E.C.3 y E.SP3.4 son con diferencia los que más variabilidad contienen. El siguiente paso por tanto es ver si esta variabilidad es fruto de un error técnico o si se pueden realizar comparaciones con la normalización de los datos.  

## Normalización de los datos

Para efectuar la normalización vamos a emplear el método más indicado para microarrays de Affymetrix, el RMA de Bioconductor que és el método estándar:

```{r}
eset_rma <- rma(rawData)
```

## Control de calidad de los datos normalizados

Al efectuar el análisis de control de calidad de los dtos una vez normalizados, vemos que se verifica la disposición de "outlier" el Array E.C.3. Sin embargo, el array E.SP3.4 ya no aparece en la lista. Estos resultados pueden corroborarse con otro Análisis de Componentes Principales para los datos estandarizados;
```{r}
#arrayQualityMetrics(eset_rma, outdir = file.path("./results", "QCDir.Norm"), force=TRUE)
```

```{r QCNormDatanRes, fig.cap="Tabla resumen de los datos del estudio normalizados", echo=FALSE}
knitr::include_graphics("Figuras/Overvieiw.norm.png")
```

```{r fig:PCANorm, message=FALSE, fig.cap="Análisis de Componentes Principales de los datos normalizados"}
plotPCA3(exprs(eset_rma), labels = eset_rma@phenoData@data[["ShortName"]], factor = eset_rma@phenoData@data[["Group"]], 
         title="Datos normalizados", scale = FALSE, size = 3, 
         colores = c("red", "blue", "green", "yellow"))
```

Con los datos normalizados vemos que el eje que explica el 22.9% de la variabilidad separa a los controles de los casos inoculados con SP3. Además podemos apreciar que el Array E.C.3 sigue estando bastante aislado del resto de sus pares. Por otra parte también podemos observar que el eje que explica un 18.2% de la variabilidad de los Arrays separa, aunque con una menor claridad, los casos "naive" (no expuestos previamente a la bacteria) de los experimentados (ratones inoculados con SP3 y recuperados previamente al experimento). 

```{r BoxplotNorm, message=FALSE, fig.cap="Boxplot con datos normalizados"}
boxplot(eset_rma, cex.axis=0.5, las=2,  which="all", 
         col = c(rep("red", 4), rep("blue", 4), rep("green", 4), rep("yellow", 4)),
         main="Boxplot de intensidades de los Arrays: Datos normalizados")
```

En este análisis se pueden apreciar mucha más similaridad en las intensidades de todos los Arrays (a excepción una vez mas del Array E.C.3). 

## Filtraje no específico

A continuación vamos a efectuar el análisis del posible ruido de fondo que puedan tener los dieferentes Arrays del estudio. Vamos a emplear el análisis de componentes principales de variación;

```{r BatchDetection, message=FALSE, warning=FALSE}
pData(eset_rma) <- my.targets@data
pct_threshold <- 0.6
batch.factors <- c("Experimental", "Cell.type")
pvcaObj <- pvcaBatchAssess (eset_rma, batch.factors, pct_threshold)
```

```{r plotPVCA, fig.cap="Importancia relativa de los factores -Grupo experimental, Tipo celular e interacción"}
bp <- barplot(pvcaObj$dat, xlab = "Effects",
  ylab = "proporcion de la varianza ponderada",
  ylim= c(0,1.1),col = c("mediumorchid"), las=2,
  main="PVCA estimado")
axis(1, at = bp, labels = pvcaObj$label, cex.axis = 0.75, las=2)
values = pvcaObj$dat
new_values = round(values , 3)
text(bp,pvcaObj$dat,labels = new_values, pos=3, cex = 0.7)
```
Como se puede observar, existe una mayor variación no biológica en este caso que es la residual. Esto hace suponer que deberían eliminarse al menos los Arrays que más ruido puedan presentar (por ejemplo el Array  E.C.3). En segundo lugar hemos corroborado que es la variabilidad explicada por el grupo experimental (diferencias entre control y experienced). Y por último, un 16% de la variabilidad sería explicada por el factor de interés en este estudio que no es otro que la diferencia entre las células "naive" y las experimentadas.

## Identificación de genes diferencialmente expresados

Viendo los resultados del apartado anterior, hay serias sospechas de que la variabilidad total de las muestras pueda enmascarar las diferencias entres los distintos grupos experimentales. Por este mitivo se procede a realizar una análisis de la variabilidad de todos los genes para ver que porcentaje de genes pueden mostrar una variabilidad distinta a la varibilidad genérica de las muestras:

```{r SDplot, fig.cap="Valores de desviaciones estándar de todas las muestras para todos los genes"}
sds <- apply (exprs(eset_rma), 1, sd)
sdsO<- sort(sds)
plot(1:length(sdsO), sdsO, main="Distribución de la variabilidad de los genes",
     sub="Vertical lines represent 90% and 95% percentiles",
     xlab="Gene index (from least to most variable)", ylab="Standard deviation")
abline(v=length(sds)*c(0.9,0.95))
```







Así podemos apreciar que existe un gran número de genes que presentan una desviación estándar mayor a 1.0, aunque no llega a ser el 5% de los genes.







### Filtrado de los genes menos variables

El siguiente paso que vamos a realizar es tratar de eliminar todos aquellos genes que puedan provocar una mayor distorsión a la hora de realizar los análisis comparativos;

```{r Filtering1, results='hide', message=FALSE}
annotation(eset_rma) <- "mogene21sttranscriptcluster.db"
filtered <- nsFilter(eset_rma, 
                     require.entrez = TRUE, remove.dupEntrez = TRUE,
                     var.filter=TRUE, var.func=IQR, var.cutoff=0.75, 
                     filterByQuantile=TRUE, feature.exclude = "^AFFX")
```

```{r FilterResults1, results='hide', echo=FALSE}
names(filtered)
class(filtered$eset)
```

```{r FilterResults2}
print(filtered$filter.log)
eset_filtered <-filtered$eset
```

Con lo que con esta función se han filtrado los genes, eliminando un total de 16710  lo cual es bastante considerable y de suponer teniendo en cuenta los análisis previos. Acontinuación guardamos el archivo obtenido para posibles análisis posteriores;
```{r SaveData1, results='hide', message=FALSE}
write.csv(exprs(eset_rma), file="./results/normalized.Data.csv")
write.csv(exprs(eset_filtered), file="./results/normalized.Filtered.Data.csv")
save(eset_rma, eset_filtered, file="./results/normalized.Data.Rda")
```

## Matriz de diseño

A continuación vamos a construir el modelo 
In this study  that "Group" variable is a combination of the two experimental conditions, "KO/Wild" and "RT/COLD" which are jointly represented as one factor with 4 levels.

```{r LoadSavedData}
if (!exists("eset_filtered")) load (file="./results/normalized.Data.Rda")
```

```{r DesignMatrix, message=FALSE}
designMat<- model.matrix(~0+Group, pData(eset_filtered))
colnames(designMat) <- c("E.C", "E.SP3", "N.C", "N.SP3")
print(designMat)
```


```{r setContrasts}
cont.matrix <- makeContrasts (Infec.E = E.C-E.SP3,
                              Infec.N = N.C-N.SP3,
                              MEM = (E.C-E.SP3) - (N.C-N.SP3),
                              levels=designMat)
print(cont.matrix)
```

En este estudio y dado el diseño del mismo, lo que interesa aquí es el efecto memoria (llamado aquí MEM) que establecen los macrófagos al experimentar previamente la infección del SP3. No obstante será interesante tambien examinar qué efecto tiene la infección de SP3 en la expresión de genes de los macrófagos de ambos grupos:

## Identificación de genes diferencialmente expresados

Vamos a obtener el listado de genes que se encuentran expresados de manera diferente según los tres casos que hemos diseñado en el apartado anterior. Para ello hemos de comprobar las pruebas de significación para cada gen y cada comparación:
```{r, linearmodelfit}
fit<-lmFit(eset_filtered, designMat)
fit.main<-contrasts.fit(fit, cont.matrix)
fit.main<-eBayes(fit.main)
class(fit.main)
```
Y con la función "Toptable" se podrán generar para cada contraste una lista de genes ordenados de mayor a menor diferencia de expresión:

Para los macrófacos experimentados;
```{r, topTabs1}
topTab_Infec.E <- topTable (fit.main, number=nrow(fit.main), coef="Infec.E", adjust="fdr") 
head(topTab_Infec.E)
```

Para los "naive";
```{r, topTabs2}
topTab_Infec.N <- topTable (fit.main, number=nrow(fit.main), coef="Infec.N", adjust="fdr") 
head(topTab_Infec.N)
```

Para el contraste de mayor interés, la diferencia entre los experimentados y "naive", o efecto memoria (MEM);
```{r, topTabs3}
topTab_MEM  <- topTable (fit.main, number=nrow(fit.main), coef="MEM", adjust="fdr") 
head(topTab_MEM)
```

## Anotación de los resultados obtenidos 

En este apartado vamos a correlacionar las etiquetas de los genes o ID. establecidas por Affimetrix con los *gene symbol*  establecidos para la descripción de cada uno de los genes:
```{r GeneAnnotation, message=FALSE, warning=FALSE}
annotatedTopTable <- function(topTab, anotPackage)
{
  topTab <- cbind(PROBEID=rownames(topTab), topTab)
  myProbes <- rownames(topTab)
  thePackage <- eval(parse(text = anotPackage))
  geneAnots <- select(thePackage, myProbes, c("SYMBOL", "ENTREZID", "GENENAME"))
  annotatedTopTab<- merge(x=geneAnots, y=topTab, by.x="PROBEID", by.y="PROBEID")
return(annotatedTopTab)
}
```

```{r annotateTopTables}
topAnnotated_Infec.E <- annotatedTopTable(topTab_Infec.E,
anotPackage="mogene21sttranscriptcluster.db")
topAnnotated_Infec.N <- annotatedTopTable(topTab_Infec.N,
anotPackage="mogene21sttranscriptcluster.db")
topAnnotated_MEM <- annotatedTopTable(topTab_MEM,
anotPackage="mogene21sttranscriptcluster.db")
write.csv(topAnnotated_Infec.E, file="./results/topAnnotated_Infec.E.csv")
write.csv(topAnnotated_Infec.N, file="./results/topAnnotated_Infec.N.csv")
write.csv(topAnnotated_MEM, file="./results/topAnnotated_MEM.csv")
show(head(topAnnotated_MEM[1:5,1:4]))
```
Y visualizamos también los datos mediante un volcanoPlot de las diferencias de memoria entre los macrófagos infectados:


```{r volcanoPlot}
library(mogene21sttranscriptcluster.db)
geneSymbols <- select(mogene21sttranscriptcluster.db, rownames(fit.main), c("SYMBOL"))
SYMBOLS<- geneSymbols$SYMBOL
volcanoplot(fit.main, coef=3, highlight=10, names=SYMBOLS, 
            main=paste("Differentially expressed genes", colnames(cont.matrix)[3], sep="\n"))
  abline(v=c(-1,1))
```

## Comparación entre distintas comparaciones

Aunque el principal motivo de este estudio es la comparación MEM, puede resultar de interés qué sucede en el resto de comparaciones con los controles. El siguiente paso es ver si hay genes están seleccionados entre las combinaciones de las comparaciones efectuadas en este estudio:
```{r decideTests.1}
library(limma)
res<-decideTests(fit.main, method="separate", adjust.method="fdr", p.value=0.1, lfc=1)
```
Con el valor +1 para los sobreexpresados y el valor -1 para los infraexpresados el punto de corte para el análisis se define como "FDR < 0.1" y "logFC > 1" (+1 para valores de t-test $>0$, FDR < punto de corte y -1 para valores de t-test $<0$,  FDR < punto de corte) tomando valores 0 para no diferencias significativas. 
```{r resumeDecideTests}
sum.res.rows<-apply(abs(res),1,sum)
res.selected<-res[sum.res.rows!=0,] 
print(summary(res))
```

Podemos observar que existe un gen sobreexpresado y otro infraexpresado que comparten el efecto memoria con los macrófagos experimentados, esto es muy informativo y llama bastante la atención. Otra manera más simplificada y visual de representar esta información sería mediante un Diagrama de Venn:
```{r, vennDiagram, fig.cap="Venn diagram showing the genes in common between the three comparisons performed"}
vennDiagram (res.selected[,1:3], cex=0.9)
title("Genes en común entre los tres grupos definidos\n Genes seleccionados mediante FDR < 0.1 y logFC > 1")
```

En este diagrama se observa el número de genes expresados diferentemente de manera significativa, pero no se ven si están infra o sobreexpresados. Para ver la información con más detalle podemos realizar el Heatmap:
```{r data4Heatmap}
probesInHeatmap <- rownames(res.selected)
HMdata <- exprs(eset_filtered)[rownames(exprs(eset_filtered)) %in% probesInHeatmap,]

geneSymbols <- select(mogene21sttranscriptcluster.db, rownames(HMdata), c("SYMBOL"))
SYMBOLS<- geneSymbols$SYMBOL
rownames(HMdata) <- SYMBOLS
write.csv(HMdata, file = file.path("./results/data4Heatmap.csv"))
```

```{r heatmapClustering, fig.cap="Heatmap de similaridad para expresión de genes (filas) y muestras (columnas)"}
my_palette <- colorRampPalette(c("blue", "red"))(n = 299)
heatmap.2(HMdata,
          Rowv = TRUE,
          Colv = TRUE,
          dendrogram = "both",
          main = "Genes expresados diferente \n FDR < 0,1, logFC >=1",
          scale = "row",
          col = my_palette,
          sepcolor = "white",
          sepwidth = c(0.05,0.05),
          cexRow = 0.5,
          cexCol = 0.9,
          key = TRUE,
          keysize = 1.5,
          density.info = "histogram",
          ColSideColors = c(rep("red",4),rep("blue",4), rep("green",4), rep("yellow",4)),
          tracecol = NULL,
          srtCol = 30)

```

## Análisis de significación biológica


En este paso trataremos de ver en qué vía metabolica tienen en común los gens que están diferenciados significativamente entre los grupos analizados. Lo vamos a realizar con el paquete `ReactomePA` de Bioconductor con un FDR < 0.15 (menos restrictivo) para tratar de asegurar el listado de genes suficientes para poder llegar a coincidencias en vías metabólicas.


```{r selectGenes}
listOfTables <- list(Infec.E = topTab_Infec.E, 
                     Infec.N  = topTab_Infec.N, 
                     MEM = topTab_MEM)
listOfSelected <- list()
for (i in 1:length(listOfTables)){
  # select the toptable
  topTab <- listOfTables[[i]]
  # select the genes to be included in the analysis
  whichGenes<-topTab["adj.P.Val"]<0.15
  selectedIDs <- rownames(topTab)[whichGenes]
  # convert the ID to Entrez
  EntrezIDs<- select(mogene21sttranscriptcluster.db, selectedIDs, c("ENTREZID"))
  EntrezIDs <- EntrezIDs$ENTREZID
  listOfSelected[[i]] <- EntrezIDs
  names(listOfSelected)[i] <- names(listOfTables)[i]
}
sapply(listOfSelected, length)
```

```{r}
mapped_genes2GO <- mappedkeys(org.Mm.egGO)
mapped_genes2KEGG <- mappedkeys(org.Mm.egPATH)
mapped_genes <- union(mapped_genes2GO , mapped_genes2KEGG)
```


```{r BiologicalSig}

listOfData <- listOfSelected[1:2]
comparisonsNames <- names(listOfData)
universe <- mapped_genes

for (i in 1:length(listOfData)){
  genesIn <- listOfData[[i]]
  comparison <- comparisonsNames[i]
  enrich.result <- enrichPathway(gene = genesIn,
                                 pvalueCutoff = 0.05,
                                 readable = T,
                                 pAdjustMethod = "BH",
                                 organism = "mouse",
                                 universe = universe)
  
  cat("##################################")
  cat("\nComparison: ", comparison,"\n")
  print(head(enrich.result))

  if (length(rownames(enrich.result@result)) != 0) {
  write.csv(as.data.frame(enrich.result), 
             file =paste0("./results/","ReactomePA.Results.",comparison,".csv"), 
             row.names = FALSE)
  
  pdf(file=paste0("./results/","ReactomePABarplot.",comparison,".pdf"))
    print(barplot(enrich.result, showCategory = 15, font.size = 4, 
            title = paste0("Reactome Pathway Analysis for ", comparison,". Barplot")))
  dev.off()
  
  pdf(file = paste0("./results/","ReactomePAcnetplot.",comparison,".pdf"))
    print(cnetplot(enrich.result, categorySize = "geneNum", schowCategory = 15, 
         vertex.label.cex = 0.75))
  dev.off()
  }
}
```


```{r network, fig.cap="Red obtenida del análisis Reactome enrichment de la lista obtenida de las comparaciones de Naive Experienced y MEM"}
  cnetplot(enrich.result, categorySize = "geneNum", schowCategory = 15, 
         vertex.label.cex = 0.75)
```


```{r tableReacto, echo=FALSE}
Tab.react <- read.csv2(file.path("./results/ReactomePA.Results.Infec.E.csv"), 
                       sep = ",", header = TRUE, row.names = 1)

Tab.react <- Tab.react[1:4, 1:5]
knitr::kable(Tab.react, booktabs = TRUE, caption = "Primeras filas y columnas de los resultados de Reactome de la comparacion de Infec.E.csv")
```

Es interesante que la vía metabólica más relevante en los cambios genéticos sea la vía del metabolismo de los fosfolípidos de membrana seguida de la de cascadas de receptores Toll-like y de la de síntesis de fosfolípidos de la membrana de formación de endosomas, así como la de señalización de Interleukinas. 



It is useful to create a file with the type, name and description of all the files generated along the analysis. Table \@ref(tab:listOfFiles) shows the list of files generated in the current case study. 

```{r listOfFiles, echo=FALSE}
listOfFiles <- dir("./results/") 
knitr::kable(
  listOfFiles, booktabs = TRUE,
  caption = 'Lista de archivos generados en el análisis',
  col.names="List_of_Files"
)
```

